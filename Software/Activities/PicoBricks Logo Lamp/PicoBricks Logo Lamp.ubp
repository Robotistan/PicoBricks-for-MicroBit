module main
author unknown
version 1 0 
description ''
variables i r g b 

script 66 50 {
comment 'PICOBRICKS LOGO LAMP:

micro:bit v1 and v2

A hand-built custom lamp with Neopixel strip is programmed
to display 6 RGBLED color sets in random fashion.

'
}

script 50 210 {
whenStarted
'_pbmb_init_lib'
neoPixelAttach 3 _pbmb_pin_RGB_LED
r = ('[data:makeList]' 18 128 62 188 139 255)
g = ('[data:makeList]' 168 135 177 8 50 60)
b = ('[data:makeList]' 168 193 136 0 0 0)
forever {
  neoPixelSetAllToColor (colorFromRGB (at 'random' r) (at 'random' g) (at 'random' b))
  waitMillis 500
}
}


module 'IR Motion (PIR)' Input
author MicroBlocks
version 1 1 
tags sensor motion presence 
description 'Detect motion with a passive infrared (PIR) sensor.'
variables _PIRs 

  spec 'r' 'PIR' 'PIR at pin _ detected movement' 'auto' '10'
  spec 'r' '_PIR' '_PIR at pin _' 'auto' '10'
  spec ' ' '_pirLoop' '_pirLoop'

to PIR pin {
  sendBroadcast '_pirLoop'
  waitUntil (_PIRs != 0)
  return (at 2 ('_PIR' pin))
}

to '_PIR' pin {
  for PIR _PIRs {
    if ((at 1 PIR) == pin) {return PIR}
  }
  local 'PIR' ('[data:makeList]' pin (booleanConstant false))
  '[data:addLast]' PIR _PIRs
  return PIR
}

to '_pirLoop' {
  if (_PIRs == 0) {_PIRs = ('[data:makeList]')}
  forever {
    for PIR _PIRs {
      if (digitalReadOp (at 1 PIR)) {
        if (not (at 2 PIR)) {atPut 2 PIR (booleanConstant true)}
      } else {
        if (at 2 PIR) {atPut 2 PIR (booleanConstant false)}
      }
    }
    waitMillis 5
  }
}


module 'IR Remote' Comm
author MicroBlocks
version 1 5 
tags ir infrared remote 
description 'Sends and receives infrared remote control messages like the ones used for TV sets or air conditioners. Currently supports only the NEC protocol, which is quite common but not the only IR protocol in use. An NEC message consists of a one byte device number and a one byte command.

Note: Transmitting IR does not work on ESP8266 boards.

Receiving requires an IR receiver module, such as those built into the Circuit Playground Express and ED1 boards. Transmitting requires an IR transmitter LED, such as those built into the Circuit Playground Express and several M5 Stack products. Inexpensive IR LED transmitter and receivers are available for use with other boards.'
variables _ir_pin _ir_pulse_times _ir_last_code _ir_last_device _ir_transmit_pin 

  spec ' ' 'attachIR' 'attach IR receiver to pin _' 'num' 0
  spec 'r' 'ir_code_received' 'IR code received?'
  spec 'r' 'ir_last_code' 'IR code'
  space
  spec ' ' 'IR_Transmit' 'IR transmit device _ command _' 'num num' 48896 1
  spec ' ' 'attachIRTransmitter' 'attach IR transmitter to pin _' 'num' 0
  space
  spec 'r' 'receiveIR' 'receive IR code'
  space
  spec ' ' '_testIR' '_test IR'
  spec 'r' '_receiveIRFromDevice' '_receive IR code from device _' 'num' 48896
  space
  spec ' ' '_captureIRMessage' '_captureIRMessage' 'any'
  spec ' ' '_dumpIR' '_dumpIR' 'any'
  spec 'r' '_getIRByte' '_getIRByte _' 'auto any' 4
  spec 'r' '_got32Bits' '_got32Bits' 'any'
  spec ' ' '_IR_SendByte' '_IR_SendByte _' 'auto' '10'

to IR_Transmit device command {
  if (_ir_transmit_pin == 0) {if (or ((boardType) == 'CircuitPlayground') ((boardType) == 'M5Atom-Matrix')) {
    _ir_transmit_pin = 12
  } (or ((boardType) == 'M5StickC') ((boardType) == 'M5StickC+')) {
    _ir_transmit_pin = 9
  }}
  comment 'Message start pulse and space'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 9000
  '[io:playTone]' _ir_transmit_pin 0
  waitMicros 4500
  comment 'Send device and command and their inverses'
  '_IR_SendByte' (device & 255)
  '_IR_SendByte' ((device >> 8) & 255)
  '_IR_SendByte' command
  '_IR_SendByte' ('~' command)
  comment 'Send stop bit'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 562
  '[io:playTone]' _ir_transmit_pin 0
  comment 'Turn off IR transmit LED'
  if (or ((boardType) == 'M5StickC') ((boardType) == 'M5StickC+')) {
    comment 'IR pin is inverted so true means "off"'
    digitalWriteOp _ir_transmit_pin true
  } else {
    digitalWriteOp _ir_transmit_pin false
  }
}

to '_IR_SendByte' byte {
  local 'bit' 1
  repeat 8 {
    if (0 == (byte & bit)) {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 530
    } else {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 1630
    }
    bit = (bit << 1)
  }
}

to '_captureIRMessage' {
  if (_ir_pulse_times == 0) {
    _ir_pulse_times = (newList 200)
    if (_ir_pin == 0) {
      if ((boardType) == 'CircuitPlayground') {
        _ir_pin = 11
      } ((boardType) == 'Citilab ED1') {
        _ir_pin = 35
      } ((boardType) == 'D1-Mini') {
        _ir_pin = 2
      } ((boardType) == 'MakerPort') {
        _ir_pin = 18
      }
    }
  }
  fillList _ir_pulse_times 0
  local 'i' 1
  comment 'Wait for IR signal -- this is the start of a new message.
Note: THe pin goes low when an IR signal is detected.'
  waitUntil (not (digitalReadOp _ir_pin))
  local 'start' (microsOp)
  forever {
    comment 'Record the time until the end of the current IR pulse ("mark")'
    waitUntil (digitalReadOp _ir_pin)
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
    comment 'Record time until the start of the next IR pulse ("space")'
    repeatUntil (not (digitalReadOp _ir_pin)) {
      if (((microsOp) - start) > 5000) {
        comment 'No IR pulse for 5000 usecs means "end of message"'
        return 0
      }
    }
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
  }
}

to '_dumpIR' {
  comment 'Print raw pulse timings to the terminal.
Can be used to analyze new protocols.'
  local 'i' 1
  printIt '-----'
  repeat (size _ir_pulse_times) {
    local 'mark usecs' (at i _ir_pulse_times)
    local 'space usecs' (at (i + 1) _ir_pulse_times)
    printIt (v 'mark usecs') (v 'space usecs')
    i += 2
    if ((v 'space usecs') == 0) {
      printIt 'timing entries:' (i - 2)
      return 0
    }
  }
}

to '_getIRByte' position {
  local 'result' 0
  local 'i' position
  local 'bit' 1
  repeat 8 {
    if ((at i _ir_pulse_times) > 1000) {result = (result | bit)}
    bit = (bit << 1)
    i += 2
  }
  return result
}

to '_got32Bits' {
  return (and ((at 67 _ir_pulse_times) != 0) ((at 68 _ir_pulse_times) == 0))
}

to '_receiveIRFromDevice' deviceID {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      local 'id_lowByte' ('_getIRByte' 4 nil)
      local 'id_highByte' ('_getIRByte' 20 nil)
      if (and (id_highByte == (deviceID >> 8)) (id_lowByte == (deviceID & 255))) {
        return ('_getIRByte' 36 nil)
      }
    }
  }
}

to '_testIR' {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      comment 'Four byte message format:
<device low byte><device high byte><command><command, bit-inverted>'
      local 'b1' ('_getIRByte' 4 nil)
      local 'b2' ('_getIRByte' 20 nil)
      local 'b3' ('_getIRByte' 36 nil)
      local 'b4' ('_getIRByte' 52 nil)
      sayIt 'Device:' ((b2 << 8) | b1) 'code:' b3
    }
  }
}

to attachIR pin {
  _ir_pin = pin
}

to attachIRTransmitter pin {
  _ir_transmit_pin = pin
}

to ir_code_received {
  return ((receiveIR) >= 0)
}

to ir_last_code {
  return _ir_last_code
}

to receiveIR {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      local 'id_lowByte' ('_getIRByte' 4 nil)
      local 'id_highByte' ('_getIRByte' 20 nil)
      _ir_last_device = ((id_highByte << 8) | id_lowByte)
      _ir_last_code = ('_getIRByte' 36 nil)
      atPut 'all' _ir_pulse_times 0
      return _ir_last_code
    }
  }
}


module 'LED Display' Output
author MicroBlocks
version 1 5 
tags pixel matrix led tft 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' '_set display color' 'set display color _' 'color'
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  space
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'

to '_set display color' color {
  callCustomCommand '[display:mbSetColor]' ('[data:makeList]' color)
}

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s))
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module 'Light & Gesture (APDS9960)' Input
author MicroBlocks
version 1 0 
choices apds9960_lightGain '1x' '4x' '16x' '64x' 
description 'Support for the APDS9960 light, color, and gesture sensor.

The sensor handles a wide range of light values thanks to the ability to change the gain. Its color response is similar to the human eye and it incorporates IR and UV blocking filters. In additional to the light level, it can report the light color as a list of red, green, and blue levels.

The gesture sensor uses reflected infrared light to detect object proximity with a range of a few centimeters. It can also detect the direction of a passing object (e.g. a hand), detecting left, right, up, or down gestures. Gestures can be used to trigger actions in MicroBlocks such as turning some device on and off in response to up and down gestures.'
variables _apds9960_addr _apds9960_gestureState _apds9960_startLR _apds9960_startUD _apds9960_gesture _apds9960_lastGesture 

  spec 'r' 'apds9960_light' 'apds9960 light'
  spec 'r' 'apds9960_color' 'apds9960 color'
  space
  spec ' ' 'apds9960_setLightGain' 'apds9960 set light gain _' 'menu.apds9960_lightGain' '4x'
  spec 'r' 'apds9960_lightGain' 'apds9960 light gain'
  space
  spec 'r' 'apds9960_proximity' 'apds9960 proximity'
  space
  spec 'r' 'apds9960_gestureAvailable' 'apds9960 gesture available'
  spec 'r' 'apds9960_lastGesture' 'apds9960 last gesture'
  space
  spec ' ' '_apds9960_initialize' '_apds9960_initialize'
  spec ' ' '_apds9960_turnOff' '_apds9960_turnOff'
  spec ' ' '_apds9960_turnOnWithoutGestures' '_apds9960_turnOnWithoutGestures'
  spec ' ' '_apds9960_turnOnAll' '_apds9960_turnOnAll'
  space
  spec ' ' '_apds9960_enableGestures' '_apds9960 enable gestures'
  spec ' ' '_apds9960_processGesture' '_apds9960_processGesture'
  spec ' ' '_apds9960_recognizeGesture' '_apds9960_recognizeGesture _ _' 'num num' 0 0
  space
  spec ' ' '_apds9960_unblockStateMachine' '_apds9960_unblockStateMachine'
  spec 'r' '_apds9960_read16bits' '_apds9960_read16bits reg _' 'num' 0

to '_apds9960_enableGestures' {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  '_apds9960_turnOff'
  local 'ggain' 3
  local 'val' (ggain << 5)
  local 'gdrive' 0
  local 'val' (val | (gdrive << 3))
  local 'gwait' 3
  local 'val' (val | gwait)
  i2cSet _apds9960_addr (hexToInt 'A3') val
  i2cSet _apds9960_addr (hexToInt 'A6') (hexToInt '84')
  comment 'A non-zero value for _apds9960_gesture indicates that gestures are enabled'
  _apds9960_gesture = 'none'
  '_apds9960_turnOnAll'
}

to '_apds9960_initialize' {
  _apds9960_addr = (hexToInt '39')
  '_apds9960_turnOff'
  comment 'Reg 0x81: Integration time. 224 gives a range of 0 to ~32768 (2^15) in about 90 msecs.'
  i2cSet _apds9960_addr (hexToInt '81') 224
  comment 'Reg 0x8E: PPULSE. 0x87 sends 8 16-usec pulses.'
  i2cSet _apds9960_addr (hexToInt '8E') (hexToInt '87')
  apds9960_setLightGain '4x'
  '_apds9960_turnOnWithoutGestures'
  waitMillis 100
}

to '_apds9960_processGesture' {
  if (_apds9960_addr == 0) {'_apds9960_enableGestures'}
  local 'thresh' 80
  local 'data' (newList 4)
  repeatUntil ((i2cGet _apds9960_addr (hexToInt 'AE')) <= 0) {
    '[sensors:i2cWrite]' _apds9960_addr (hexToInt 'FC')
    '[sensors:i2cRead]' _apds9960_addr data
    comment 'These variables reflect the standard orientation of the Databot (USB cable is down).'
    local 'left' (at 1 data)
    local 'right' (at 2 data)
    local 'up' (at 3 data)
    local 'down' (at 4 data)
    if (0 == _apds9960_gestureState) {
      comment 'State 0: idle; all channels below threshold'
      if (or (or (left > thresh) (right > thresh)) (or (up > thresh) (down > thresh))) {
        _apds9960_startLR = (right - left)
        _apds9960_startUD = (down - up)
        _apds9960_gestureState = 1
      }
    } (1 == _apds9960_gestureState) {
      comment 'State 1: rising; one channel has risen above threshold'
      if (and (and (left > thresh) (right > thresh)) (and (up > thresh) (down > thresh))) {
        _apds9960_gestureState = 2
      }
    } (2 == _apds9960_gestureState) {
      comment 'State 2: all channels above threshold'
      if (or (or (left < thresh) (right < thresh)) (or (up < thresh) (down < thresh))) {
        '_apds9960_recognizeGesture' (right - left) (down - up)
        _apds9960_gestureState = 3
      }
    } else {
      comment 'State 3: falling; one channel had fallen below threshold'
      if (and (and (left < thresh) (right < thresh)) (and (up < thresh) (down < thresh))) {
        _apds9960_gestureState = 0
      }
    }
  }
}

to '_apds9960_read16bits' reg {
  local 'lowByte' (i2cGet _apds9960_addr reg)
  local 'highByte' (i2cGet _apds9960_addr (reg + 1))
  return ((highByte << 8) | lowByte)
}

to '_apds9960_recognizeGesture' endLR endUD {
  local 'minChange' 10
  local 'totalLR' (absoluteValue (_apds9960_startLR - endLR))
  local 'totalUP' (absoluteValue (_apds9960_startUD - endUD))
  if (totalLR > totalUP) {
    if (totalLR < minChange) {return}
    if ((_apds9960_startLR - endLR) < 0) {
      _apds9960_gesture = 'left'
    } else {
      _apds9960_gesture = 'right'
    }
  } else {
    if (totalUP < minChange) {return}
    if ((_apds9960_startUD - endUD) < 0) {
      _apds9960_gesture = 'down'
    } else {
      _apds9960_gesture = 'up'
    }
  }
}

to '_apds9960_turnOff' {
  i2cSet _apds9960_addr (hexToInt '80') 0
}

to '_apds9960_turnOnAll' {
  i2cSet _apds9960_addr (hexToInt '80') (64 | 7)
}

to '_apds9960_turnOnWithoutGestures' {
  i2cSet _apds9960_addr (hexToInt '80') 7
}

to '_apds9960_unblockStateMachine' {
  comment 'If an object is close to the sensor, the state machine
remains in gesture mode. This will unblock it, freeing
the sensor to update the light and color readings.'
  i2cSet _apds9960_addr (hexToInt 'AB') 0
}

to apds9960_color {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  '_apds9960_unblockStateMachine'
  local 'r' ('_apds9960_read16bits' (hexToInt '96'))
  local 'g' ('_apds9960_read16bits' (hexToInt '98'))
  local 'b' ('_apds9960_read16bits' (hexToInt '9A'))
  return ('[data:makeList]' r g b)
}

to apds9960_gestureAvailable {
  if (0 == _apds9960_gesture) {'_apds9960_enableGestures'}
  '_apds9960_processGesture'
  _apds9960_lastGesture = _apds9960_gesture
  _apds9960_gesture = 'none'
  if ('none' == _apds9960_lastGesture) {
    return false
  }
  return true
}

to apds9960_lastGesture {
  if (0 == _apds9960_lastGesture) {return 'none'}
  return _apds9960_lastGesture
}

to apds9960_light {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  '_apds9960_unblockStateMachine'
  return ('_apds9960_read16bits' (hexToInt '94'))
}

to apds9960_lightGain gain {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  local 'gainSetting' ((i2cGet _apds9960_addr (hexToInt '8F')) & 3)
  return (1 << (2 * gainSetting))
}

to apds9960_proximity {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  '_apds9960_unblockStateMachine'
  return (i2cGet _apds9960_addr (hexToInt '9C'))
}

to apds9960_setLightGain gain {
  if (_apds9960_addr == 0) {'_apds9960_initialize'}
  local 'drive' 0
  if ('1x' == gain) {
    drive = 0
  } ('4x' == gain) {
    drive = 1
  } ('16x' == gain) {
    drive = 2
  } ('64x' == gain) {
    drive = 3
  }
  local 'val' (i2cGet _apds9960_addr (hexToInt '8F'))
  val = ((val & 252) | (drive & 3))
  i2cSet _apds9960_addr (hexToInt '8F') val
}


module NeoPixel Output
author MicroBlocks
version 1 7 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    local 'brightness' (maximum r g b)
    if (delta > 0) {
      delta = (minimum delta (255 - brightness))
    } else {
      delta = (maximum delta (42 - brightness))
    }
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 300
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module 'PicoBricks-mb'
author MicroBlocks
version 0 85 
depends 'IR Motion (PIR)' 'IR Remote' 'Light & Gesture (APDS9960)' NeoPixel 'Temperature Humidity (SHTC3)' Tone 
choices servoNumMenu 'S1:3' 'S2:4' 'S3:5' 'S4:6' ALL 
choices dcNumMenu 'M1:1' 'M2:2' ALL 
choices configMenu 'ALL:FF,7F' 'X&Y Only:07,00' 'Arrows Only:F1,00' 'Keyboard Only:09,7F' 'X&Y and Arrows Only:F7,00' 
choices touchMenu ANY X Y Up Right Down Left c d e f g a b c1 
choices dcDirMenu 'Fwd:0' 'Bwd:1' 
description 'Robotistan PicoBricks Library 
*** micro:bit version ***

This library controls these PicoBricks components:

- Temperature and humidity (SHTC3) I2C:0x70
- IR Motion (PIR)
- Relay Switch (5V-250V, 5A)
- 2xDC & 4xSERVO Motors (HK32F030) I2C:0x22
- IR Remote 
- Light & Gesture (APDS9960) I2C:0x39
- Light sensor (Light Dependent Resistor)
- Potentiometer (variable resistor)
- Button on POT
- 14ch TOUCH Panel (CY8CMBR3116) I2C:0x37

Use separate libraries to control:
- LED Display
- NeoPixel WS2812 3xRGB LED
- OLED Graphic display (TFT or OLED Libs)
- WIFI-ESP01 expansion board

See https://www.robotistan.com, 
https://wiki.microblocks.fun/en/picobricks,
https://github.com/Robotistan/picobricks-for-microbit-ext/tree/master

CHANGES:
- updated Config process, less displays, error codes in _pbmb_current_config
- faster and smaller dec2hex with pad
- name changes
- auto config detect
- force string for hex2dec for config 
- adjust startup "invalid config"
- change key and gesture names to camelcase
- SERVO range 0-193 (internal)
- Block Config changes on micro:bit v1
- Change buttons to X&Y
- dec2hex name correction
- stop touch on error
- ignore touch not in table
- synch to R
- remove micro:bit v1 ConfigChange restriction
- c1 correction
- config change bug correction
- motor command displays off
'
variables _pbmb_initialized _pbmb_pin_Button _pbmb_pin_Relay _pbmb_pin_Pot _pbmb_pin_LDR _pbmb_pin_Buzzer _pbmb_pin_RGB_LED _pbmb_pin_TX _pbmb_pin_RX _pbmb_motor_i2c _pbmb_touch_i2c _pbmb_pin_PIR _pbmb_pin_IRrecv i2cStat _pbmb_touched i2cBuffer _pbmb_kvTable _pbmb_lastKeyTouched _pbmb_current_config _pbmb_config_completed _pbmb_crcTable _pbmb_configNames _pbmb_configTable option 

  space
  spec 'r' 'pbmb_humidity' 'PicoBricks-mb humidity'
  spec 'r' 'pbmb_temperature' 'PicoBricks-mb temperature (°C)'
  spec 'r' 'pbmb_pir' 'PicoBricks-mb PIR detected'
  spec ' ' 'pbmb_set_relay' 'PicoBricks-mb set relay _' 'bool' true
  space
  spec ' ' 'pbmb_set_motor_speed' 'PicoBricks-mb set motor _ speed _ (0-255) dir _' 'menu.dcNumMenu num menu.dcDirMenu' 1 128 0
  spec ' ' 'pbmb_set_servo_angle' 'PicoBricks-mb set servo _ angle _ (0-180)' 'menu.servoNumMenu num' 1 90
  space
  spec 'r' 'pbmb_ir_code_received' 'PicoBricks-mb IR Code Received?'
  spec 'r' 'pbmb_ir_code' 'PicoBricks-mb IR Code'
  spec 'r' 'pbmb_ir_recv_code' 'PicoBricks-mb Receive IR Code'
  space
  spec 'r' 'pbmb_gest_color' 'PicoBricks-mb GS Color : as color# _' 'bool' false
  spec 'r' 'pbmb_gest_avail' 'PicoBricks-mb GS Detected'
  spec 'r' 'pbmb_gest_lastgest' 'PicoBricks-mb GS Last Gesture'
  spec 'r' 'pbmb_gest_light' 'PicoBricks-mb GS Light'
  spec 'r' 'pbmb_gest_prox' 'PicoBricks-mb GS Proximity'
  space
  spec 'r' 'pbmb_light_sensor' 'PicoBricks-mb light sensor (0-100) %'
  spec 'r' 'pbmb_potentiometer' 'PicoBricks-mb Potentiometer'
  spec 'r' 'pbmb_button' 'PicoBricks-mb Pot Button'
  space
  spec 'r' 'pbmb key _ pressed' 'PicoBricks-mb Touchkey _ pressed ?' 'menu.touchMenu' 'ANY'
  spec 'r' 'pbmb Last key touched' 'PicoBricks-mb Last key touched'
  space
  spec ' ' '_pbmb_init_lib' '_PicoBricks-mb init Library'
  spec ' ' '_pbmb_wakeup' '_PicoBricks-mb WakeUp'
  spec ' ' '_pbmb_configureTouch' '_PicoBricks-mb configure Touch Options _' 'menu.configMenu' 'FF,7F'
  spec ' ' '_pbmb_Config-2' '_Config-2'
  spec ' ' '_pbmb_Config-3' '_Config-3'
  spec ' ' '_pbmb_read_ConfigRegs' '_pbmb_read_ConfigRegs'
  spec 'r' '_pbmb_Config&CRC' '_PicoBricks-mb show Touch Config&CRC'
  spec 'r' '_pbmb_dec2hex' '_pbmb_dec2hex _ Pad _' 'num num' 0 2
  spec ' ' '_pbmb_config_initTables' '_pbmb_config_initTables'
  spec ' ' '_pbmb_Config-1' 'obsolete obsolete _Config-1'

to '_pbmb_Config&CRC' {
  comment 'OK'
  '_pbmb_config_initTables'
  '_pbmb_read_ConfigRegs'
  if (_pbmb_current_config != 0) {
    local 'idx' ('[data:find]' _pbmb_current_config _pbmb_configTable)
  } else {
    local 'crc' ('[data:join]' (at 127 i2cBuffer) ',' (at 128 i2cBuffer))
    local 'idx' ('[data:find]' crc _pbmb_crcTable)
  }
  if (-1 != idx) {
    _pbmb_current_config = (at idx _pbmb_configTable)
    local 'config' (at idx _pbmb_configNames)
  } else {
    comment 'Config search Failed...
variable config contains an Error message.'
    local 'config' 'Unrecognized Config.'
  }
  local 'crc' ('[data:join]' 'CRC: ' '0x' ('_pbmb_dec2hex' (at 127 i2cBuffer) 2) ', ' '0x' ('_pbmb_dec2hex' (at 128 i2cBuffer) 2) '  (' (at 127 i2cBuffer) ', ' (at 128 i2cBuffer) ')')
  return ('[data:join]' 'Config: ' config ('[data:unicodeString]' 10) crc)
}

to '_pbmb_Config-2' {
  comment 'I2C write 128 byte CONFIG @ memory 0'
  _pbmb_touch_i2c = (hexToInt '37')
  '_pbmb_wakeup'
  local 'idx' 1
  for reg ('[data:range]' 0 127) {
    i2cSet _pbmb_touch_i2c reg (at idx i2cBuffer)
    idx += 1
  }
  sayIt 'CONFIG Written' idx
  '_pbmb_Config-3'
}

to '_pbmb_Config-3' {
  comment 'Wait till processor is ready.'
  _pbmb_touch_i2c = (hexToInt '37')
  waitUntil (0 == (i2cGet _pbmb_touch_i2c (hexToInt '86')))
  comment 'CTRL_CMD / SAVE_CHECK_CRC '
  i2cSet _pbmb_touch_i2c (hexToInt '86') 2
  sayIt 'CONFIG2EEPROM attempted.'
  waitMillis 300
  comment 'CTRL_CMD Error check:
0: Command was successful
253: Write to flash failed
254: Stored configuration CRC checksum (in CONFIG_CRC register) did not match 
calculated configuration CRC checksum
255: Invalid command '
  i2cStat = ('[data:makeList]' 44)
  '[sensors:i2cWrite]' _pbmb_touch_i2c ('[data:makeList]' (hexToInt '89'))
  '[sensors:i2cRead]' _pbmb_touch_i2c i2cStat
  if ('0' == ('[data:joinStrings]' i2cStat)) {
    comment 'Wait till processor is ready.'
    waitUntil (0 == (i2cGet _pbmb_touch_i2c (hexToInt '86')))
    comment 'CTRL_CMD / SW_RESET '
    i2cSet _pbmb_touch_i2c (hexToInt '86') 255
    waitMillis 500
    _pbmb_config_completed = (booleanConstant true)
    sayIt 'CONFIG Successful...'
  } ('254' == ('[data:joinStrings]' i2cStat)) {
    sayIt 'CRC ERROR: Correcting'
    waitMillis 500
    comment 'Write CRC into CONFIG 0x7E, 0x7F'
    atPut 127 i2cBuffer (i2cGet _pbmb_touch_i2c (hexToInt '94'))
    atPut 128 i2cBuffer (i2cGet _pbmb_touch_i2c (hexToInt '95'))
    '_pbmb_Config-2'
  } else {
    sayIt 'ERROR: Aborting'
    _pbmb_config_completed = ('[data:join]' 'Error: ' ('[data:joinStrings]' i2cStat))
  }
}

to '_pbmb_config_initTables' {
  _pbmb_configNames = ('[data:makeList]' 'ALL' 'X&Y Only' 'Arrows Only' 'Keyboard Only' 'X&Y and Arrows Only')
  _pbmb_configTable = ('[data:makeList]' 'FF,7F' '07,00' 'F1,00' '09,7F' 'F7,00')
  _pbmb_crcTable = ('[data:makeList]' '135,4' '50,139' '104,197' '221,74' '77,84')
  _pbmb_kvTable = ('[data:makeList]' 'X' '2,0' 'Y' '4,0' 'Up' '16,0' 'Right' '32,0' 'Down' '64,0' 'Left' '128,0' 'c' '8,0' 'd' '0,64' 'e' '0,32' 'f' '0,16' 'g' '0,8' 'a' '0,4' 'b' '0,2' 'c2' '0,1' 'None' '0,0')
}

to '_pbmb_configureTouch' option {
  comment '*** DO NOT make a Config change with any of the Touch blocks running ***

128 Byte CONFIG Register settings:

FIRST 126 bytes are CONFIG DATA (starts with Options)
Last 2 bytes are CRC.
CRC is initially 00,00.
It is calculated by the sensor during the config process based on the options selected
and adjusted (Config-3).

*** WARNING ***
DO NOT CHANGE VALUES BELOW UNLESS YOU ARE SURE ABOUT THEIR
MEANING AND REGISTER LOCATIONS.
'
  local 'configData' ('[data:joinStrings]' ('[data:split]' option ','))
  configData = ('[data:join]' configData 'FE7F00000000000000000E848484848484848484848484848484030000000000000000000181060000FFF002000000000000000000000000000000000000')
  comment 'I2CAddr is byte# 82 = 0x37
CRC-16 : LAST TWO hex-BYTES below'
  configData = ('[data:join]' configData '00FFFFFFFFFFFFFFFF0000000003015800370600000A000000000000000000000000000000000000000000000000000000000000000000000000000000000000')
  local 'idx' 1
  i2cBuffer = ('[data:newByteArray]' 128)
  for i ('[data:range]' 1 (size configData) 2) {
    atPut idx i2cBuffer (hexToInt ('[data:copyFromTo]' configData i (i + 1)))
    idx += 1
  }
  sayIt 'I2Cbuffer Ready.'
  '_pbmb_Config-2'
  waitUntil (_pbmb_config_completed != (booleanConstant false))
  if _pbmb_config_completed {
    _pbmb_current_config = option
  } else {
    comment '_pbmb_current_config contains ERROR info'
  }
}

to '_pbmb_dec2hex' num pad {
  comment 'Fast version w/o inversion. (~115uSecs)'
  local '_hexTbl' '0123456789ABCDEF'
  local 'hexNum' ''
  repeatUntil (num < 0) {
    if ((num / 16) != 0) {
      hexNum = ('[data:join]' (at ((num % 16) + 1) _hexTbl) hexNum)
      num = (num / 16)
    } else {
      hexNum = ('[data:join]' (at ((num % 16) + 1) _hexTbl) hexNum)
      num = -1
    }
  }
  comment 'If not half-byte length, pad it.'
  repeatUntil (((size hexNum) % pad) == 0) {
    hexNum = ('[data:join]' '0' hexNum)
  }
  return hexNum
}

to '_pbmb_init_lib' {
  comment 'OK'
  comment 'Touch sensor remembers previous config and starts with it
upon power on. 

Current running Config can be displayed with 
show Touch Config&CRC block; and changed with 
configure Touch Options.
'
  if _pbmb_initialized {
    return
  }
  '_pbmb_config_initTables'
  _pbmb_motor_i2c = 34
  _pbmb_touch_i2c = 55
  _pbmb_pin_RGB_LED = 8
  neoPixelAttach 3 _pbmb_pin_RGB_LED
  _pbmb_pin_Button = 2
  _pbmb_pin_PIR = 13
  _pbmb_pin_Relay = 16
  _pbmb_pin_Pot = 1
  _pbmb_pin_LDR = 0
  _pbmb_pin_IRrecv = 15
  attachIR _pbmb_pin_IRrecv
  if ((boardType) == 'micro:bit v2') {
    _pbmb_pin_Buzzer = 27
    'attach buzzer to pin' _pbmb_pin_Buzzer
    _pbmb_pin_TX = 14
    _pbmb_pin_RX = 15
    '[serial:close]'
    callCustomCommand '[serial:setPins]' ('[data:makeList]' 15 14)
  }
  _pbmb_initialized = (booleanConstant true)
}

to '_pbmb_read_ConfigRegs' {
  comment 'OK'
  _pbmb_touch_i2c = (hexToInt '37')
  '_pbmb_wakeup'
  comment 'I2C read only reads 32 bytes !!!!'
  i2cBuffer = ('[data:makeList]')
  i2cStat = (newList 32 99)
  for i ('[data:makeList]' 0 32 64 96) {
    '[sensors:i2cWrite]' _pbmb_touch_i2c ('[data:makeList]' i)
    '[sensors:i2cRead]' _pbmb_touch_i2c i2cStat
    i2cBuffer = ('[data:join]' i2cBuffer i2cStat)
  }
  i2cBuffer = ('[data:asByteArray]' i2cBuffer)
  sayIt 'CONFIG copied into i2cBuffer'
}

to '_pbmb_wakeup' {
  comment 'WAKE UP'
  _pbmb_touch_i2c = (hexToInt '37')
  repeat 4 {
    i2cStat = (i2cGet _pbmb_touch_i2c 0)
  }
}

to 'pbmb Last key touched' {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return _pbmb_lastKeyTouched
}

to 'pbmb key _ pressed' touchKey {
  comment 'OK: non-looping version'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  comment 'Read TOUCH Status'
  local 'buttonStat' 0
  _pbmb_touched = (newList 1)
  '_pbmb_wakeup'
  '[sensors:i2cWrite]' _pbmb_touch_i2c ('[data:makeList]' (hexToInt 'AE'))
  '[sensors:i2cRead]' _pbmb_touch_i2c _pbmb_touched
  if (255 == (at 1 _pbmb_touched)) {
    comment '255 = I2C error occurred.'
    _pbmb_touched = (booleanConstant false)
    stopTask
  } else {
    _pbmb_touched = ('[data:convertType]' (at 1 _pbmb_touched) 'boolean')
  }
  comment 'Read Button Status'
  buttonStat = (newList 2)
  '[sensors:i2cWrite]' _pbmb_touch_i2c ('[data:makeList]' (hexToInt 'AA'))
  '[sensors:i2cRead]' _pbmb_touch_i2c buttonStat
  if _pbmb_touched {
    local 'touchVal' ('[data:joinStrings]' buttonStat ',')
    local 'idx' ('[data:find]' touchVal _pbmb_kvTable)
    if (-1 != idx) {
      _pbmb_lastKeyTouched = (at (idx - 1) _pbmb_kvTable)
    } else {
      return (booleanConstant false)
    }
    if ('ANY' == touchKey) {
      comment 'This check has to happen after the key name is determined.'
      return (booleanConstant true)
    } else {
      if (touchVal == (at (('[data:find]' touchKey _pbmb_kvTable) + 1) _pbmb_kvTable)) {
        return (booleanConstant true)
      } else {
        return (booleanConstant false)
      }
    }
  } else {
    return (booleanConstant false)
  }
}

to pbmb_beep duration {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  '[io:playTone]' _pbmb_pin_Buzzer 300
  waitMillis duration
  '[io:playTone]' _pbmb_pin_Buzzer 0
}

to pbmb_button {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return (digitalReadOp _pbmb_pin_Button)
}

to pbmb_gest_avail {
  comment 'OK'
  return (apds9960_gestureAvailable)
}

to pbmb_gest_color colorNum {
  comment 'OK'
  local 'color' (apds9960_color)
  local 'r' (at 1 color)
  local 'g' (at 2 color)
  local 'b' (at 3 color)
  if colorNum {
    color = ((r << 16) + ((g << 8) + b))
  }
  return color
}

to pbmb_gest_lastgest {
  comment 'OK'
  comment 'GESTURE Transpose:
For correct lookup, names have to be different.
left =  Up
right =  Down
down = Left
up = Right
'
  local 'transposeTable' ('[data:makeList]' 'down' 'Left' 'left' 'Up' 'right' 'Down' 'up' 'Right' 'none' 'None')
  return (at (('[data:find]' (apds9960_lastGesture) transposeTable) + 1) transposeTable)
}

to pbmb_gest_light {
  comment 'OK'
  return (apds9960_light)
}

to pbmb_gest_prox {
  comment 'OK'
  return (apds9960_proximity)
}

to pbmb_humidity {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return (shtc3_humidity)
}

to pbmb_ir_code {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return (ir_last_code)
}

to pbmb_ir_code_received {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return (ir_code_received)
}

to pbmb_ir_recv_code {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return (receiveIR)
}

to pbmb_light_sensor {
  comment 'OK'
  comment 'Returns Light Values s a percentage:
0: dark ,  100: light'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return ('[misc:rescale]' (analogReadOp _pbmb_pin_LDR) 0 1023 100 0)
}

to pbmb_pir {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return (PIR _pbmb_pin_PIR)
}

to pbmb_potentiometer {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return (analogReadOp _pbmb_pin_Pot)
}

to pbmb_set_motor_speed which speed dir {
  comment 'OK'
  comment 'WORKING Motor Control
Does not drive single motor @ 60 and below
and dual motors @128 and below'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  speed = (maximum 0 (minimum speed 255))
  if ('ALL' == which) {
    local 'from' 1
    local 'to' 2
  } else {
    local 'from' which
    local 'to' which
  }
  for i ('[data:range]' from to) {
    '[sensors:i2cWrite]' _pbmb_motor_i2c ('[data:asByteArray]' ('[data:makeList]' (hexToInt '26') i speed dir ((i ^ speed) ^ dir)))
  }
}

to pbmb_set_relay aBoolean {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  digitalWriteOp _pbmb_pin_Relay aBoolean
}

to pbmb_set_servo_angle which angle {
  comment 'OK'
  comment 'WORKING Servo Control
Can drive +13 degrees for adjustment.'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  angle = (maximum 0 (minimum angle 193))
  if ('ALL' == which) {
    local 'from' 3
    local 'to' 6
  } else {
    local 'from' which
    local 'to' which
  }
  for i ('[data:range]' from to) {
    '[sensors:i2cWrite]' _pbmb_motor_i2c ('[data:asByteArray]' ('[data:makeList]' (hexToInt '26') i 0 angle (i ^ angle)))
    waitMillis 75
  }
}

to pbmb_temperature {
  comment 'OK'
  if (not _pbmb_initialized) {
    '_pbmb_init_lib'
  }
  return (shtc3_temperature)
}


module TFT Output
author MicroBlocks
version 1 7 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _ : bg color _' 'str num num color num bool color' 'Hello World!' 5 5 nil 2 true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  spec ' ' '[tft:drawBitmap]' 'draw bitmap _ palette _ on TFT at x _ y _' 'str str num num' 'aBitmap' 'a list of colors' 10 10
  space
  spec 'r' 'tft_colorSwatch' '_' 'color'
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to tft_colorSwatch color {
  return color
}


module 'Temperature Humidity (SHTC3)' Input
author MicroBlocks
version 1 3 
description 'Support for the SHTC3 temperature and relative humidity sensor.'

  spec 'r' 'shtc3_temperature' 'SHTC3 temperature (°C)'
  spec 'r' 'shtc3_humidity' 'SHTC3 relative humidity (%)'
  space
  spec ' ' '_shtc3_send_cmd' '_shtc3_send_cmd _' 'num' 0
  spec 'r' '_shtc3_read' '_shtc3_read'
  spec 'r' '_shtc3_crcOkay' '_shtc3_crcOkay _ _ _' 'num num num' 0 0 0

to '_shtc3_crcOkay' b1 b2 b3 {
  local 'crc' 255
  for i 2 {
    if (1 == i) {
      crc = (crc ^ b1)
    } else {
      crc = (crc ^ b2)
    }
    repeat 8 {
      if ((crc & 128) != 0) {
        crc = (((crc << 1) ^ 49) & 255)
      } else {
        crc = (crc << 1)
      }
    }
  }
  return (0 == (crc ^ b3))
}

to '_shtc3_read' {
  local 'SHTC addr' (hexToInt '70')
  comment 'Wakeup'
  '_shtc3_send_cmd' (hexToInt '3517')
  comment 'Read data, temperature first (with clock stretching)'
  '_shtc3_send_cmd' (hexToInt '7CA2')
  local 'sixBytes' (newList 6)
  '[sensors:i2cRead]' (v 'SHTC addr') sixBytes
  comment 'Do not send sleep command; that results in i2c error on next call'
  return sixBytes
}

to '_shtc3_send_cmd' cmd {
  local 'SHTC addr' (hexToInt '70')
  '[sensors:i2cWrite]' (v 'SHTC addr') ('[data:makeList]' ((cmd >> 8) & 255) (cmd & 255))
}

to shtc3_humidity {
  local 'data' ('_shtc3_read')
  local 'high' (at 4 data)
  local 'low' (at 5 data)
  if (not ('_shtc3_crcOkay' high low (at 6 data))) {
    return 0
  }
  local 'humidity' ((100 * ((high << 8) | low)) >> 16)
  if ('Databot' == (boardType)) {
    comment 'Adjust for extra heat from PC board'
    humidity += 10
  }
  return humidity
}

to shtc3_temperature {
  local 'data' ('_shtc3_read')
  local 'high' (at 1 data)
  local 'low' (at 2 data)
  if (not ('_shtc3_crcOkay' high low (at 3 data))) {
    return 0
  }
  local 'temperature' (((175 * ((high << 8) | low)) >> 16) - 45)
  if ('Databot' == (boardType)) {
    temperature += -10
    comment 'Adjust for extra heat from PC board'
  }
  return temperature
}


module Tone Output
author MicroBlocks
version 1 8 
tags tone sound music audio note speaker 
choices tone_NoteName c 'c#' d 'd#' e f 'f#' g 'g#' a 'a#' b 
description 'Audio tone generation. Make music with MicroBlocks!'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  space
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  space
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  space
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'c' 'c#' 'd' 'd#' 'e' 'f' 'f#' 'g' 'g#' 'a' 'a#' 'b' 'c_' 'db' 'd_' 'eb' 'e_' 'e#' 'f_' 'gb' 'g_' 'ab' 'a_' 'bb' 'b_' 'b#')
    _toneArezzoNotes = ('[data:makeList]' 'do' 'do#' 're' 're#' 'mi' 'fa' 'fa#' 'sol' 'sol#' 'la' 'la#' 'si' 'do_' 'dob' 're_' 'reb' 'mi_' 'mi#' 'fa_' 'solb' 'sol_' 'lab' 'la_' 'sib' 'si_' 'si#')
  }
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

